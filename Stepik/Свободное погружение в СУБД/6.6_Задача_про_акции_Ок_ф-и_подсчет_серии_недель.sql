--Ссылка на задачу: https://stepik.org/lesson/344702/step/5?auth=login&unit=328392

/*Задача 

Это задание настоятельно рекомендуется решать с помощью оконных функций. Вам может пригодиться документация.

Позанимаемся анализом биржевых котировок.

У вас есть таблица StockQuotes(company TEXT, week INT, share_price INT). Строка в этой таблице говорит о том, что стоимость акции компании company в неделю номер week составляла share_price.

Назовём индексом в данную неделю среднее арифметическое роста стоимости одной акции по всем компаниям сравнительно с предыдущей неделей. То есть, если одна акция компании A подорожала на 100 единиц, а акция компании B подешевела на 50 единиц, то индекс равен 25.

Назовём компанию успешной на этой неделе, если изменение стоимости одной её акции было выше индекса. "Изменение D выше индекса I" означает "D > I" как вещественное число.

Если компания была успешной три недели подряд то будем говорить, что она сделала успешную серию. Успешные серии могут пересекаться. Так, если компания была успешной 5 недель подряд, то у неё было 3 успешных серии.

Вам нужно посчитать для каждой компании количество успешных серий и вывести в результат два столбца. В первом столбце с типом TEXT должно быть название компании, а во втором с типом BIGINT количество её успешных серий. Тип BIGINT, скорее всего, получится автоматически, но вы можете явно привести результат оператором ::BIGINT. При несоответствии типов ожидаемым  вам предложат проверить, нет ли в запросе синтаксических ошибок и возвращает ли он ровно то, что требуется. Это же сообщение может появиться и по другим поводам, например если у вас действительно есть синтаксические ошибки.

Компании, у которых не было успешных серий, выводить в результат не надо совсем.
Все компании различные.
Все цены положительные.
Нумерация недель начинается с 0. На неделе номер 0, разумеется, не определены рост и индекс -- вы можете считать что они 0, NULL или просто игнорировать нулевую неделю тем или иным способом при расчёте успешных недель.

Пример валидного, но неправильного ответа:

SELECT 'Foo'::TEXT, 0::BIGINT
*/

--Коммент к задаче
/*
1) Считаем с помощью оконных функций для компании сумму на этой недели минус сумму на предыдущей AS delta_prev
2) С помощью оконных функций находим сумму delta_prev по всем компаниям для каждой недели и делим на кол-во компаний также посчитанных для каждой недели AS index_week
3) delta_prev > index_week 
4) Я с помощью CASE WHEN и оконных функций, проставила 1 той записи, после которой 2 строки на один больше, чем текущая неделя. Затем посчитала сумму, сгруппировав  по компаниям. тут нужно быть внимательными, потому что сумма из пункта 5 считается по этим единичкам.
5) Вывести нужно название компании и сумму удачных серий. Если таких серий не было, компанию не выводить. Прочитайте и можно даже на листочке порисовать, чтобы понять, что это значит: 
Если компания была успешной три недели подряд то будем говорить, что она сделала успешную серию. Успешные серии могут пересекаться. Так, если компания была успешной 5 недель подряд, то у неё было 3 успешных серии.

*/

--Решение

WITH changes 
	AS (
	SELECT 
		company,
		week,
		share_price,
		(share_price - LAG(share_price, 1, share_price) OVER (PARTITION BY company ORDER BY week))::BIGINT delta_prev
	FROM stockquotes
	),
	lag_avg_week
	AS (
	SELECT 
		company,
		week,
		share_price,
		delta_prev,
		ROUND(SUM(delta_prev) OVER(PARTITION BY week) / COUNT(company) OVER(PARTITION BY week))  as index_week
	FROM changes
	),
	best_ac
	AS (
	SELECT *
	FROM lag_avg_week
	WHERE delta_prev > index_week
	),
	best_seria
	AS (
	SELECT company,
		CASE 
			WHEN 
				LEAD(week, 1, 0) OVER comp_week - week = 1
					AND
				LEAD(week, 2, 0) OVER comp_week - LEAD(week, 1, 0) OVER comp_week = 1
			THEN 1
			ELSE 0
		END AS sum_sec
	FROM best_ac
	WINDOW comp_week AS (PARTITION BY company ORDER BY week)
		ORDER BY company, week 
	)

SELECT company, SUM(sum_sec) 
FROM best_seria
GROUP BY company
HAVING SUM(sum_sec) > 0